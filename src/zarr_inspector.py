#!/usr/bin/env python
#
# zarr_inspector.py
# Script to inspect the structure and metadata of Zarr archives
# generated by the fish tracking pipeline.
#
# Usage: python zarr_inspector.py /path/to/your/data.zarr

import zarr
import argparse
import json
import os
import numpy as np
from rich.console import Console
from rich.table import Table
from rich.tree import Tree
from rich import box
from rich.panel import Panel

# --- Helper Function ---
def format_bytes(size: int) -> str:
    """Converts bytes to a human-readable format (KB, MB, GB)."""
    if size is None or size == 0:
        return "0 B"
    power = 1024
    n = 0
    power_labels = {0: '', 1: 'K', 2: 'M', 3: 'G', 4: 'T'}
    while size >= power and n < len(power_labels) - 1:
        size /= power
        n += 1
    return f"{size:.2f} {power_labels[n]}B"

def detect_data_format(root):
    """Detects the data format based on tracking result columns."""
    if 'tracking_runs' in root and 'latest' in root['tracking_runs'].attrs:
        latest_run = root['tracking_runs'].attrs['latest']
        tracking_results = root[f'tracking_runs/{latest_run}/tracking_results']
        if 'column_names' in tracking_results.attrs:
            column_names = tracking_results.attrs['column_names']
            if len(column_names) >= 20 and 'bbox_x_norm_ds' in column_names:
                return 'multi-scale', column_names
            elif len(column_names) == 9:
                return 'single-scale', column_names
    return 'unknown', []

def inspect_yolo_readiness(root, data_format):
    """Inspects YOLO training readiness based on the data format."""
    console = Console()
    
    panel_content = []
    border_style = "yellow"

    if data_format == 'multi-scale':
        panel_content.append("Multi-scale tracking data found.")
        border_style = "green"
        latest_run = root['tracking_runs'].attrs['latest']
        tracking_results = root[f'tracking_runs/{latest_run}/tracking_results']
        column_names = tracking_results.attrs.get('column_names', [])
        
        coord_systems = []
        if 'bbox_x_norm_ds' in column_names:
            coord_systems.append("640x640 (YOLO-ready)")
        if 'bbox_x_norm_full' in column_names:
            coord_systems.append("4512x4512 (full-res)")
        if 'bladder_x_roi_norm' in column_names:
            coord_systems.append("ROI normalized")
        
        panel_content.append(f"Coordinate systems: {len(coord_systems)}")
        for system in coord_systems:
            panel_content.append(f"   - {system}")
        
        if 'summary_statistics' in root[f'tracking_runs/{latest_run}'].attrs:
            stats = root[f'tracking_runs/{latest_run}'].attrs['summary_statistics']
            panel_content.append(f"Tracked frames: {stats.get('frames_tracked', 'N/A')}/{stats.get('total_frames', 'N/A')}")
        
        panel_content.append("\nReady for flexible YOLO dataset generation.")
        
    else:
        panel_content.append("Single-scale or unknown pipeline format detected.")

    yolo_panel = Panel("\n".join(panel_content), title="YOLO Training Readiness", border_style=border_style)
    console.print(yolo_panel)

def analyze_pipeline_performance(root, column_names):
    """Analyzes performance and data quality for all pipeline stages."""
    console = Console()
    
    # --- Cropping Performance ---
    if 'crop_runs' in root and 'latest' in root['crop_runs'].attrs:
        latest_run_name = root['crop_runs'].attrs['latest']
        latest_run_group = root[f'crop_runs/{latest_run_name}']
        
        if 'summary_statistics' in latest_run_group.attrs:
            stats = latest_run_group.attrs['summary_statistics']
            crop_table = Table(title="Cropping Performance", box=box.ROUNDED)
            crop_table.add_column("Metric", style="cyan")
            crop_table.add_column("Value", style="green")
            crop_table.add_row("Total Frames", str(stats.get('total_frames', 'N/A')))
            crop_table.add_row("Successfully Cropped", str(stats.get('frames_cropped', 'N/A')))
            crop_table.add_row("Success Rate", f"{stats.get('percent_cropped', 0):.2f}%")
            console.print(crop_table)

    # --- Tracking Performance ---
    if 'tracking_runs' in root and 'latest' in root['tracking_runs'].attrs:
        latest_run_name = root['tracking_runs'].attrs['latest']
        latest_run_group = root[f'tracking_runs/{latest_run_name}']
        
        if 'summary_statistics' in latest_run_group.attrs:
            stats = latest_run_group.attrs['summary_statistics']
            perf_table = Table(title="Tracking Performance", box=box.ROUNDED)
            perf_table.add_column("Metric", style="cyan")
            perf_table.add_column("Value", style="green")
            
            perf_table.add_row("Total Frames", str(stats.get('total_frames', 'N/A')))
            perf_table.add_row("Successfully Tracked", str(stats.get('frames_tracked', 'N/A')))
            perf_table.add_row("Success Rate", f"{stats.get('percent_tracked', 0):.2f}%")
            
            if 'confidence_stats' in stats:
                conf = stats['confidence_stats']
                perf_table.add_row("Avg Confidence", f"{conf.get('mean', 0):.3f}")

            console.print(perf_table)

def inspect_coordinate_systems(root):
    """Inspects coordinate system documentation from the latest tracking run."""
    console = Console()
    if 'tracking_runs' not in root or 'latest' not in root['tracking_runs'].attrs:
        return
        
    latest_run = root['tracking_runs'].attrs['latest']
    coord_group_path = f'tracking_runs/{latest_run}/coordinate_systems'
    
    if coord_group_path not in root:
        return
        
    coord_group = root[coord_group_path]
    console.print("\n[bold]Coordinate Systems Documentation[/bold]")
    
    for coord_name, coord_info in coord_group.attrs.items():
        table = Table(title=f"Coordinate System: {coord_name}", box=box.MINIMAL)
        table.add_column("Property", style="cyan")
        table.add_column("Value", style="white")
        
        for key, value in coord_info.items():
            value_str = str(value)
            if isinstance(value, list) and len(value) > 3:
                value_str = f"{len(value)} columns"
            table.add_row(key, value_str)
        
        console.print(table)

# --- Core Inspection Functions ---
def print_attributes_table(console: Console, title: str, attributes: zarr.attrs.Attributes, root_group: zarr.hierarchy.Group):
    """Creates a table for Zarr attributes."""
    if not attributes:
        return

    table = Table(title=title, box=box.ROUNDED, show_header=True, header_style="bold magenta")
    table.add_column("Attribute Key", style="dim", width=35)
    table.add_column("Value")

    for key, value in attributes.items():
        if isinstance(value, dict):
            if key == 'summary_statistics':
                rate_key = 'percent_cropped' if 'percent_cropped' in value else 'percent_tracked'
                frames_key = 'frames_cropped' if 'frames_cropped' in value else 'frames_tracked'
                stats_str = f"Success: {value.get(frames_key, 'N/A')}/{value.get('total_frames', 'N/A')} ({value.get(rate_key, 0):.1f}%)"
                table.add_row(key, f"[green]{stats_str}[/green]")
            
            # --- MODIFICATION: Display parameters for the 'best' run ---
            elif key == 'best':
                run_name = value.get('run_name', 'N/A')
                success_rate = value.get('percent_cropped', value.get('percent_tracked', 0))
                
                best_str = f"Run: '{run_name.split('/')[-1]}' | Success: {success_rate:.2f}%"
                
                # Now, try to get the parameters from that specific run
                if run_name in root_group:
                    best_run_group = root_group[run_name]
                    if 'parameters' in best_run_group.attrs:
                        params = best_run_group.attrs['parameters']
                        params_str = json.dumps(params, indent=2)
                        best_str += f"\n[dim]Parameters:[/dim]\n{params_str}"
                
                table.add_row(key, f"[bold green]{best_str}[/bold green]")
            else:
                table.add_row(key, json.dumps(value, indent=2))
        else:
            table.add_row(key, str(value))

    console.print(table)


def print_datasets_summary(console: Console, title: str, group: zarr.hierarchy.Group):
    """Creates a summary table for datasets in a group."""
    datasets = {name: obj for name, obj in group.items() if isinstance(obj, zarr.core.Array)}

    if not datasets:
        return

    table = Table(title=title, box=box.ROUNDED, show_header=True, header_style="bold magenta")
    table.add_column("Dataset Name", style="cyan", no_wrap=True)
    table.add_column("Shape", style="green")
    table.add_column("Chunks", style="yellow")
    table.add_column("Dtype", style="blue")
    table.add_column("Size", style="red", justify="right")
    table.add_column("Info", style="magenta")

    for name, dset in datasets.items():
        extra_info = ""
        if name == 'tracking_results':
            if 'column_names' in dset.attrs:
                col_count = len(dset.attrs['column_names'])
                extra_info = f"Multi-scale ({col_count} cols)" if col_count >= 20 else f"Single-scale ({col_count} cols)"
        elif name in ['images_full', 'images_ds']:
            extra_info = "Video data"
        elif name == 'roi_images':
            extra_info = "Fish crops"
        elif 'coordinates' in name:
            extra_info = "ROI coordinates"
        elif name == 'effective_thresholds':
            extra_info = "Adaptive thresholds used"

        table.add_row(
            name, str(dset.shape), str(dset.chunks), str(dset.dtype),
            format_bytes(dset.nbytes), extra_info
        )
    console.print(table)

def build_zarr_tree(group: zarr.hierarchy.Group, tree_branch: Tree):
    """Builds a tree view of the Zarr archive structure."""
    group_items = sorted(list(group.groups()))
    dataset_items = sorted(list(group.arrays()))

    for name, grp_obj in group_items:
        branch = tree_branch.add(f"[bold blue]{name}/[/bold blue]")
        build_zarr_tree(grp_obj, branch)
    
    for name, arr_obj in dataset_items:
        tree_branch.add(f"[green]{name}[/green]  [dim]({arr_obj.shape}, {arr_obj.dtype})[/dim]")

def inspect_zarr_archive(zarr_path: str):
    """Main function to inspect a Zarr archive."""
    console = Console()
    console.rule(f"[bold]Zarr Inspector: {os.path.abspath(zarr_path)}[/bold]", style="bold white")

    if not os.path.exists(zarr_path):
        console.print(f"\n[bold red]Error:[/bold red] Path does not exist: '{zarr_path}'")
        return
        
    try:
        root = zarr.open(zarr_path, mode='r')
    except Exception as e:
        console.print(f"\n[bold red]Error:[/bold red] Could not open Zarr archive at '{zarr_path}'. Details: {e}")
        return

    data_format, column_names = detect_data_format(root)
    
    banner = Panel(f"Detected data format: [bold]{data_format}[/bold]", title="Data Format", border_style="blue")
    console.print(banner)

    console.print("\n[bold]Archive Structure[/bold]")
    tree = Tree("[bold cyan]root[/bold cyan]")
    build_zarr_tree(root, tree)
    console.print(tree)
    console.rule(style="white")

    inspect_yolo_readiness(root, data_format)
    analyze_pipeline_performance(root, column_names)
    inspect_coordinate_systems(root)

    groups_to_inspect = [('/', root)] + sorted([(name, grp) for name, grp in root.groups()])
    for name, group in groups_to_inspect:
        title = f"Inspecting Group: '{name}'"
        console.print(f"\n\n[bold white on blue] {title.center(80)} [/bold white on blue]")
        # --- MODIFICATION: Pass the root group to the function ---
        print_attributes_table(console, f"Attributes for Group '{name}'", group.attrs, root)
        print_datasets_summary(console, f"Datasets in Group '{name}'", group)

def main():
    parser = argparse.ArgumentParser(
        description="Inspector for fish tracking Zarr archives.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("zarr_path", type=str, help="Path to the Zarr archive directory to inspect.")
    args = parser.parse_args()

    inspect_zarr_archive(args.zarr_path)

if __name__ == "__main__":
    main()